
"""
This module listens for events from another part of the openflow substem, openflow.discovery,
and uses them to depict the network topology in terms of nodes and links between them.

This code is an alternation of the original openflow.topology module of the pox distribution.
Credits to the original authors.

Topology should generate a topology change event whenever a link up/down event happens or when a switch
connection up/down event happens.
Topology should also generate a topology converged event after a time that no new events have happened to inform
the other modules that the topology has converged.

MUST:


LOOK INTO:
Check if we can get link capacity by exchanging some message with the openflow switch:
On features reply on the
beginning i get port info which suggest that the current ports of the switch support 10GB-Copper. This is because on
mininet i reduce the link bw using tc. But this info is not coming from the tc but from the veth pair info which are
hardcoded in the linux kernel. With that in mind i cannot get the true values from message exchanging via OF. In real
switches then the feature reply will return the true values and you could use these.
"""

from pox.lib.revent import *
from pox.core import core
from pox.lib.util import str_to_dpid, dpid_to_str
from pox.lib.recoco import Timer
from MyTopoClasses import *
import time


log = core.getLogger()

class TopologyChange (Event):
# Topology change event due to link up/down or connection up/down
    def __init__ (self, link = None, dpid = None, switch_add = None, link_add = None):
        Event.__init__(self)
        self.link = link
        self.dpid = dpid
        self.switch_added = switch_add
        self.switch_removed = not switch_add
        self.link_added = link_add
        self.link_removed = not link_add

class TopologyConverged (Event):
# Event generated at the beginning of running the module to inform other modules that topology has converged
    def __init__ (self):
        Event.__init__(self)

class MyTopologyState (EventMixin, object):
# Listens to various OpenFlow-specific events and uses those to manipulate Topology accordingly.
# Maybe check if we should send a port info message after switch is created so we can populate switch ports before
# receiving link events.
    _core_name = "current_topology"

    _eventMixin_events = set([TopologyChange, TopologyConverged])

    def __init__ (self):
        core.openflow_discovery.addListeners(self)
        core.openflow.addListeners(self)
        # Initialize the attributes that represent the network topology/state.
        self.Switches = [] # list of switches in the network
        self.Links = [] # list of network topology's core links (not links to hosts)
        self.converged = time.time()
        Timer (3, self.checkConverged, recurring = True)

    def _handle_LinkEvent (self, event):
        """
        The discovery module simply sends out LLDP packets, and triggers
        LinkEvents for discovered switches. It's our job to take these
        LinkEvents and update the topology.

        This case handles cases that a link is activated or deactivated. A link event is generated by discovery
        when a new link is discovered, an existing link goes down or a whole switch is disconnected. In this part we
        handle the first two cases when a switch is activated/deactivated. The case of a whole switch going down is
        handled by the ConnectionDown handler of this class.
        """
        rcvd_link = event.link
        sw1 = self.getSwitchByDPID(rcvd_link.dpid1) # getSwitchByDPID should return the index of the switch in the list else none
        sw2 = self.getSwitchByDPID(rcvd_link.dpid2)

        if sw1 is None or sw2 is None:
            log.debug("A switch for that link does not exist..")
            return

        # p1 = self.findPort(sw1.dpid, rcvd_link.port1)
        # p2 = self.findPort(sw1.dpid, rcvd_link.port2)

        if event.added:
            # Update port information for the affected switches
            # If link was just added, add an active port to the switch
            log.debug("New link activated between switches %s and %s.", dpid_to_str(sw1.dpid), dpid_to_str(sw2.dpid))
            # if p1 is None:
            #     temp_p = port(rcvd_link.port1, rcvd_link.dpid2, rcvd_link.port2)
            #     sw1.ports.append(temp_p)
            #     log.debug("Created port in switch %s", dpid_to_str(sw1.dpid))
            # else:
            #     log.debug("A port already exists in switch %s list of ports.", dpid_to_str(sw1.dpid))
            # if p2 is None:
            #     temp_p = port(rcvd_link.port2, rcvd_link.dpid1, rcvd_link.port1)
            #     sw2.ports.append(temp_p)
            #     log.debug("Created port in switch %s", dpid_to_str(sw2.dpid))
            # else:
            #     log.debug("A port already exists in switch %s list of ports.", dpid_to_str(sw2.dpid))
            check = self.findLink(rcvd_link.dpid1, rcvd_link.port1, rcvd_link.dpid2, rcvd_link.port2)
            if check:
                log.debug("Link already exists.. Doing nothing..")
                return
            else:
                # add link
                log.debug("Creating new unidirectional link in the Link list.")
                temp_l = link(sw1=rcvd_link.dpid1, port1=rcvd_link.port1, sw2=rcvd_link.dpid2, port2=rcvd_link.port2)
                self.Links.append(temp_l)
                # temp_l = link(sw1=rcvd_link.dpid2, port1=rcvd_link.port2, sw2=rcvd_link.dpid1, port2=rcvd_link.port1)
                # self.Links.append(temp_l)
                self.converged = time.time()
                self.raiseEventNoErrors(TopologyChange, link = rcvd_link, link_add = True)
                log.debug("Link between ports %i -> %i Created.", temp_l.port1, temp_l.port2)
        elif event.removed:
            # Remove port information form switches
            # Remove link information from link list
            log.debug("Link disconnected between switches %s and %s.", dpid_to_str(rcvd_link.dpid1), dpid_to_str(rcvd_link.dpid2))
            # if p1 is not None:
            #     sw1.ports.remove(p1)
            # else:
            #     log.debug("Port for the removed link does not exist in switch %s", dpid_to_str(sw1.dpid))
            # if p2 is not None:
            #     sw2.ports.remove(p2)
            # else:
            #     log.debug("Port for the removed link does not exist in switch %s", dpid_to_str(sw2.dpid))
            log.debug("Removing unidirectional links from the Links list.")
            check = self.findLink(rcvd_link.dpid1, rcvd_link.port1, rcvd_link.dpid2, rcvd_link.port2)
            if not check:
                log.debug("Link cannot be removed because... it doesn't exist")
            else:
                self.Links.remove(check)
                self.converged = time.time()
                self.raiseEventNoErrors(TopologyChange, link = rcvd_link, link_add = None)
                log.debug("Link Removed")
            # for l in self.Links: # Find the links that i need to remove
            #     if (l.sw1 == rcvd_link.dpid1 or l.sw1 == rcvd_link.dpid2) and (l.sw2 == rcvd_link.dpid2 or l.sw2 == rcvd_link.dpid1):
            #         if (l.port1 == rcvd_link.port1 or l.port1 == rcvd_link.port2) and (l.port2 == rcvd_link.port1 or l.port2 == rcvd_link.port2):
            #             self.Links.remove(l)

    def _handle_ConnectionUp (self, event):
        # create a new switch and add it to a list - in case you want to keep switch specific information
        sw = self.getSwitchByDPID(event.dpid)
        add = False
        if sw is None:
            sw = switch(event.dpid)
            add = True
            log.info("Switch " + dpid_to_str(event.dpid) + " connected")
        if add:
            self.Switches.append(sw)
            self.converged = time.time()
            self.raiseEventNoErrors(TopologyChange, dpid = event.dpid, switch_add = True)

    def _handle_ConnectionDown (self, event):
        # remove switch from the list of active switches
        sw = self.getSwitchByDPID(event.dpid)
        if sw is None:
          log.warn("Switch %s disconnected, but... it doesn't exist!" %
                   (dpid_to_str(event.dpid)))
        else:
            for l in self.Links:
                if l.sw1 == event.dpid or l.sw2 == event.dpid:
                    self.Links.remove(l)
            self.Switches.remove(sw)
            log.info("Switch " + str(event.dpid) + " disconnected")
            self.converged = time.time()
            self.raiseEventNoErrors(TopologyChange, dpid = event.dpid, switch_add = None)

    def checkConverged(self):
        if time.time() - self.converged >= 10:
            log.debug("Generating TopologyConverged event..")
            self.raiseEventNoErrors(TopologyConverged)
            return False # to stop Timer

    def getSwitchByDPID(self, dpid):
        # searches in the Switches list and returns the switch that matches the dpid
        if self.Switches:
            for s in self.Switches:
                if s.dpid == dpid:
                    return s
            return None
        else:
            return None

    # def findPort (self, dpid, port):
    # # find if port exists in the dpid switch
    #     for s in self.Switches:
    #         for p in s.ports:
    #             if p.number == port:
    #                 return p
    #     return None

    def findLink(self, sw1, port1, sw2, port2 = None):
        for l in self.Links:
            if l.sw1 == sw1 and l.port1 == port1 and l.sw2 == sw2:
                return l
        return None # if not found

    def getLinkCost(self, sw1, port1, sw2, port2 = None):
        for l in self.Links:
            if l.sw1 == sw1 and l.port1 == port1 and l.sw2 == sw2:
                return l.link_cost
        return None # if not found

    def resetLinkCounters(self):
        log.debug("Reseting link counters")
        for l in self.Links:
            l.cur_counter = 0

    def updateLinkCounters(self, byte_count, sw1, port1, sw2, port2 = None): # called by monitoring module to update link info after polling
        l = self.findLink(sw1 = str_to_dpid(sw1), port1 = port1, sw2 = str_to_dpid(sw2))
        if l is not None:
            log.debug("Found link that i need to increment current counter for. From %s to %s", sw1, sw2)
            l.cur_counter = l.cur_counter + byte_count # calculate accumulated byte count for this polling period
            log.debug("Incremented current counter by %i bytes. New counter value is %i", byte_count, l.cur_counter)

    def calculateLoads(self, stamp):
        log.debug("Opening file")
        f = open('LinkStats', 'a') # write load on file with timestamp
        log.debug("Calculating loads and writing to file")
        for l in self.Links:
            # log.debug("%s | %s Link Counters before--> Prev: %i, Current: %i", l.sw1,l.sw2,l.prev_counter,l.cur_counter)
            l.last_load = l.cur_counter - l.prev_counter # calculate load for every link (load = current-previous)
            l.prev_counter = l.cur_counter # change previous to current
            l.link_cost = ((l.last_load/5)*100)/l.capacity # /self.polling
            # log.debug("%s | %s Link Counters after--> Prev: %i, Current: %i, Load: %i", l.sw1,l.sw2,l.prev_counter,l.cur_counter,l.last_load)
            f.write(stamp+";"+dpid_to_str(l.sw1)+";"+str(l.port1)+";"+dpid_to_str(l.sw2)+";"+str(l.port2)+";"+str(l.last_load)+";"+str(l.capacity)+";"+str(l.link_cost)+";\n")
        log.debug("Finished writing to file")
        f.close()

    def removeFlowBytes(self, byte_count, sw1, port1, sw2, port2 = None):
        l = self.findLink(sw1 = str_to_dpid(sw1), port1 = port1, sw2 = str_to_dpid(sw2))
        if l is not None:
            log.debug("Found link that i need to decrease prev counter for. From %s to %s", sw1, sw2)
            # log.debug("%s | %s Link Counters before removing FlowRemoved stats--> Prev: %i", l.sw1, l.sw2, l.prev_counter)
            l.prev_counter = l.prev_counter - byte_count # remove total flow removed byte count from counter
            # l.cashed_flrmv_count=f.byte_count # cache value for future use
            log.debug("Decreased prev counter by %i bytes. New counter value is %i", byte_count, l.prev_counter)

def launch ():
  if not core.hasComponent("current_topology"):
    core.registerNew(MyTopologyState)

